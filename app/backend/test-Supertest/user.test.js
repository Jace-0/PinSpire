/* Integration Tests: User Management & Social Features
 * - Authentication
 * - Profile Operations
 * - Follow Relationships and Notifications
 * - WebSocket Communications
 */

const logger = require('../util/logger')
const { test, before, after, describe } = require('node:test')
const assert = require('node:assert')
const path = require('path')
const { sequelize } = require('../util/db')
const { User, Follower, Chat, Message } = require('../models/index')
const jwt = require('jsonwebtoken')
const redisClient = require('../util/redis')
const WebSocket = require('ws')

const {
  app,
  server,
  createUser,
  loginUser,
  refreshToken,
  logout,
  updateUserProfileData,
  updateUserProfileAvatar,
  followUser,
  checkFollowStatus,
  createChat,
  sendMessage
} = require('./test_helper')


let port
before(async () => {
  try {
    await sequelize.authenticate()
    logger.info('Test database connected')
    port = server.listen().address().port

  } catch (error) {
    logger.error('Database connection failed:', error)
    throw error
  }
})

after(async () => {
  try {
    await sequelize.close()
    logger.info('Test database connection closed')
  } catch (error) {
    logger.error('Error closing database:', error)
    throw error
  }
})



const testUsers = {
  JACE: {
    email: 'jace@test.com',
    password: 'Test123!@#',
    dob: '2001-01-01'
  },
  invalid: {
    email: 'invalid@example.com',
    password: '123',
    dob: 'invalid-date'
  },
  MATTI : {
    email: 'matti@test.com',
    password: 'salenen',
    dob: '2001-01-02'
  }
}
let JACE, JACE_TOKENS
let MATTI, MATTI_TOKENS
let jaceNotificationPayload
let jaceWsClient
let mattiNotificationPayload
let mattiWsClient

/* AUTHENTICATION INTEGRATION TEST */
describe('Authentication Tests', async () => {
  before(async () => {
    try {
      // PostgreSQL-specific: Disable triggers temporarily
      await sequelize.query('SET session_replication_role = replica')

      // Clean all tables that might have references
      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
      ])

      // Re-enable triggers
      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }
  })

  describe('User Registration', () => {
    test('Successfully creates new user with valid data', async () => {
      const response = await createUser(testUsers.JACE)
        .expect(201)
        .expect('Content-Type', /application\/json/)

      JACE = response.body.user
      JACE_TOKENS = {
        accessToken: response.body.accessToken,
        refreshToken: response.body.refreshToken
      }
      // Verify response structure
      assert.ok(response.body.user, 'Response should contain user object')
      assert.ok(response.body.accessToken, 'Response should contain access token')
      assert.ok(response.body.refreshToken, 'Response should contain refresh token')

      // Verify user data
      const { user } = response.body
      assert.ok(user.id, 'User should have an ID')
      assert.ok(user.username, 'User should have a username generated by the system from email')
      assert.ok(!user.password, 'Password should not be returned')
    })


    test('Prevents duplicate user registration', async () => {
    // // First registration
    //   await createUser(testUsers.JACE).expect(201)

      // Attempt duplicate registration
      const response = await createUser(testUsers.JACE)
        .expect(409)
        .expect('Content-Type', /application\/json/)

      assert.equal(response.body.error, 'Email already exists')
    })

    test('Validates required fields', async () => {
      const invalidUsers = [
        { password: 'test123', dob: '2001/1/1' }, // Missing email
        { email: 'test@example.com', dob: '2001/1/1' }, // Missing password
        { email: 'test@example.com', password: 'test123' } // Missing dob
      ]

      for (const invalidUser of invalidUsers) {
        const response = await createUser(invalidUser)
          .expect(400)
          .expect('Content-Type', /application\/json/)

        assert.ok(response.body.error, 'Should return error message')
        assert.equal(response.body.error, 'Email, password and date of birth are required')
      }
    })
  })

  describe('User Login', () => {

    test('Successfully logs in with valid credentials', async () => {
      const credentials = {
        email: testUsers.JACE.email,
        password: testUsers.JACE.password
      }

      const response = await loginUser(credentials)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      // Verify response structure
      assert.ok(response.body.user, 'Response should contain user object')
      assert.ok(response.body.accessToken, 'Response should contain access token')
      assert.ok(response.body.refreshToken, 'Response should contain refresh token')

      // Verify user data
      const { user } = response.body
      assert.ok(!user.password, 'Password should not be returned')
    })

    test('Rejects invalid credentials', async () => {
      const invalidCredentials = [
        { email: testUsers.JACE.email, password: testUsers.invalid.password },
        { email: testUsers.invalid.email, password: testUsers.JACE.password }
      ]

      for (const credentials of invalidCredentials) {
        const response = await loginUser(credentials)
          .expect(401)
          .expect('Content-Type', /application\/json/)

        assert.equal(response.body.error, 'Invalid credentials')
      }
    })
  })

  describe('Token Refresh Tests', () => {
    test('Successfully refreshes access token', async () => {
      const response = await refreshToken()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send({ refreshToken: JACE_TOKENS.refreshToken })
        .expect(200)
        .expect('Content-Type', /application\/json/)

      // Verify response
      assert.ok(response.body.accessToken, 'Should return new access token')
      assert.ok(response.body.refreshToken, 'Should return new refresh token')
      assert.notEqual(
        response.body.accessToken,
        JACE_TOKENS.accessToken,
        'New access token should be different'
      )
      assert.notEqual(
        response.body.refreshToken,
        JACE_TOKENS.refreshToken,
        'New refresh token should be different'
      )


      // Check if new token is not blacklisted
      const isNotBlacklisted = await redisClient.get(`bl_${response.body.refreshToken}`)
      assert.equal(isNotBlacklisted, null, 'New token should not be blacklisted')

      // Updated JACE Tokens
      JACE_TOKENS = {
        accessToken: response.body.accessToken,
        refreshToken: response.body.refreshToken
      }

    })

    test('Rejects invalid token formats', async () => {
      // JWT will return 401 for these cases
      const invalidTokens = [
        'not-a-token',
        'invalid.jwt.format',
        `${JACE_TOKENS.refreshToken}corrupted`
      ]

      for (const invalidToken of invalidTokens) {
        await refreshToken()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .send({ refreshToken: invalidToken })
          .expect(401)  // JWT verification fails with 401
          .expect('Content-Type', /application\/json/)
      }
    })

    test('Rejects blacklisted valid format tokens', async () => {
      // First use valid tokens
      const newTokens = await refreshToken()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send({ refreshToken: JACE_TOKENS.refreshToken })
        .expect(200)


      // Try to reuse the now-blacklisted token
      const blacklistedResponse = await refreshToken()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send({ refreshToken: JACE_TOKENS.refreshToken })
        .expect(400)  // Blacklisted token returns 400
        .expect('Content-Type', /application\/json/)

      assert.strictEqual(
        blacklistedResponse.body.error,
        'Token has been revoked',
        'Should reject blacklisted token'
      )

      // Verify Token is Blacklisted on redis
      const isBlacklisted = await redisClient.get(`bl_${JACE_TOKENS.refreshToken}`)
      assert.equal(isBlacklisted, 'true', 'Old token should be blacklisted')

      // Updated JACE Tokens
      JACE_TOKENS = {
        accessToken: newTokens.body.accessToken,
        refreshToken: newTokens.body.refreshToken
      }
    })

    test('Accepts request with NO Authorization header Reject with non', async () => {

      // Try with NO Authorization Header
      const newTokens = await refreshToken()
        .set('Authorization', 'Bearer invalid-accessToken')
        .send({ refreshToken: JACE_TOKENS.refreshToken })
        .expect(200)  // when accessToken is no longer valid, or expired

      // Updated JACE Tokens
      JACE_TOKENS = {
        accessToken: newTokens.body.accessToken,
        refreshToken: newTokens.body.refreshToken
      }


      // Try with NO refresh Token
      const noTokenResponse = await refreshToken()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .expect(400)

      assert.ok(noTokenResponse.body.error)
      assert.equal(noTokenResponse.body.error, 'No token', 'Should respond with No Token' )
    })

    test('Rejects expired refresh tokens', async () => {
      // Create an expired token
      const expiredToken = jwt.sign(
        { id: JACE.id },
        process.env.REFRESH_SECRET,
        { expiresIn: '0s' }
      )

      await refreshToken()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send({ refreshToken: expiredToken })
        .expect(401)  // Expired tokens return 401
        .expect('Content-Type', /application\/json/)
    })

  })

  describe('User Log out',() => {
    test('Successfully Log out and access token blacklisted ', async () => {
      // // Register testUser
      // const registerResponse  = await createUser(testUsers.JACE)
      //   .expect(201)
      //   .expect('Content-Type', /application\/json/)


      // const { accessToken } = registerResponse.body

      const response = await logout()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      assert.equal(response.body.message, 'Logged out successfully' )

      //  check if token is blacklisted
      const isBlacklisted = await redisClient.get(`bl_${JACE_TOKENS.accessToken}`)
      assert.equal(isBlacklisted, 'true', 'Token should be blacklisted')

    })
  })

})


describe('User API Tests', async () => {
  before(async () => {
    try {
      await sequelize.query('SET session_replication_role = replica')
      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
      ])
      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }
  })

  describe('User Profile Update test', () => {

    before(async () => {
      const response = await createUser(testUsers.JACE)
        .expect(201)
        .expect('Content-Type', /application\/json/)
      JACE = response.body.user
      JACE_TOKENS = {
        accessToken: response.body.accessToken,
        refreshToken: response.body.refreshToken
      }
    })

    test('should update user and return 200 status with updated data when valid updates provided', async () => {
      const updates = {
        first_name: 'Jace',
        last_name: 'Sam',
        bio: 'Software Developer',
        website_url: 'https://example.com',
        gender: 'male',
        country: 'CH',
        language: 'de'
      }

      const response = await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send(updates)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      const { success, data } = response.body

      delete data.created_at
      delete data.updated_at

      assert.ok(success)
      assert.deepStrictEqual(data, {
        ...updates,
        id: JACE.id,
        email: testUsers.JACE.email,
        username: JACE.username,
        dob: '2001-01-01', // Match the exact format returned by the database,
        avatar_url: JACE.avatar_url
      })
    })


    test('should remove sensitive fields from update object before processing', async () => {
      const updates = {
        first_name: 'Jace',
        password: 'NewSecret123!', // password is removed
        email: 'new@example.com', // email is removed,
      }

      const response = await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send(updates)
        .expect(200)

      assert.ok(response.body.success)
      assert.ok(!response.body.data.password)
    })


    test('should invalidate redis cache after successful update', async () => {
      const updates = { first_name: 'Jace' }

      // Update user
      await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send(updates)
        .expect(200)

      // Verify cache is invalidated
      const cachedData = await redisClient.get(`user${JACE.id}`)
      assert.equal(cachedData, null)
    })


    test('should handle empty update object gracefully', async () => {
      const response = await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send({})
        .expect(400)

      assert.equal(response.body.error, 'No update data provided')
    })


    test('should ignore invalid field names in update object', async () => {
      const updates = {
        first_name: 'Jace',
        invalidField: 'Invalid Value'
      }

      const response = await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send(updates)
        .expect(200)

      assert.ok(response.body.success)
      assert.equal(response.body.data.first_name, 'Jace')
      assert.ok(!response.body.data.invalidField)
    })


    test('should handle database errors gracefully', async () => {
      // Force a database error by passing invalid data type
      const updates = {
        username: null //  username doesn't accept null
      }

      const response = await updateUserProfileData()
        .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
        .send(updates)
        .expect(400)

      assert.strictEqual(response.body.error, 'Validation error')
      assert.strictEqual(response.body.details[0].field, 'username')
      assert.strictEqual(response.body.details[0].message, 'User.username cannot be null')
      assert.strictEqual(response.body.details[0].type, 'notNull Violation')

    })



    // Avatar update Test
    describe('User Avatar Update Tests', async () => {
      // profile Image path
      const testImagePath = path.join(__dirname, 'test-files/profile.jpeg')

      test('should update user avatar and return 200 when valid file and ID provided', async () => {

        const response = await updateUserProfileAvatar()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .attach('avatar', testImagePath) // .attach() handles the FormData creation internally
          .expect(200)
          .expect('Content-Type', /application\/json/)

        assert.ok(response.body.success)
        assert.notStrictEqual(response.body.data.avatar_url, JACE.avatar_url)
      })



      test('should return user data without password_hash when update successful', async () => {

        const response = await updateUserProfileAvatar()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .attach('avatar', testImagePath)
          .expect(200)

        assert.strictEqual(response.body.success, true)
        assert.ok(!response.body.data.password_hash)
        assert.ok(response.body.data.id)
        assert.ok(response.body.data.username)
      })

      test('should invalidate Redis cache when avatar update successful', async () => {

        await updateUserProfileAvatar()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .attach('avatar', testImagePath)
          .expect(200)

        const isInvlidated = await redisClient.get(`user:${JACE.username}`)

        assert.equal(isInvlidated, null, 'User should Invalidated')
      })

      test('should return 400 when no image file provided', async () => {
        const response = await updateUserProfileAvatar()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .expect(400)

        assert.strictEqual(response.body.success, false)
        assert.strictEqual(response.body.message, 'No image file provided')
      })


      test('should handle missing file', async () => {
        const response = await updateUserProfileAvatar()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .expect(400)

        assert.strictEqual(response.body.success, false)
        assert.strictEqual(response.body.message, 'No image file provided')
      })

    })

  })

  describe('User interaction test ', () => {
    before(async () => {
      try {
        await sequelize.query('SET session_replication_role = replica')

        await Promise.all([
          User.destroy({ truncate: true, cascade: true }),
          Follower.destroy({ truncate: true, cascade: true }),
          Chat.destroy({  truncate: true, cascade: true }),
          Message.destroy({  truncate: true, cascade: true }),
        ])

        await sequelize.query('SET session_replication_role = default')
      } catch (error) {
        logger.error('Database cleanup error', error)
        throw error
      }
    })

    before(async () => {
      // target user (who will receive notification)
      const targetResponse  = await createUser(testUsers.JACE)
        .expect(201)
        .expect('Content-Type', /application\/json/)
      JACE = targetResponse.body.user
      JACE_TOKENS = {
        accessToken: targetResponse.body.accessToken,
        refreshToken: targetResponse.body.refreshToken
      }

      // Create a follower user for testing Notification and chat functionality
      const user = await createUser(testUsers.MATTI)
        .expect(201)

      MATTI = user.body.user
      MATTI_TOKENS = {
        accessToken: user.body.accessToken,
        refreshToken: user.body.refreshToken
      }

      // Initialize WebSocket client for user (JACE)
      jaceWsClient = new WebSocket(
        `ws://localhost:${port}?token=${JACE_TOKENS.accessToken}`
      )

      // Initialize WebSocket client for user (MATTI)
      mattiWsClient = new WebSocket(
        `ws://localhost:${port}?token=${MATTI_TOKENS.accessToken}`
      )

      // Wait for WebSocket connection with proper error handling
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('WebSocket connection timeout'))
        }, 5000)

        jaceWsClient.on('open', () => {
          clearTimeout(timeout)
          logger.info(' jaceWsClient connected successfully')
          resolve()
        })
        mattiWsClient.on('open', () => {
          clearTimeout(timeout)
          logger.info('mattiWsClient connected successfully')
          resolve()
        })

        jaceWsClient.on('error', (error) => {
          clearTimeout(timeout)
          logger.error('jaceWsClient connection error:', error)
          reject(error)
        })
        mattiWsClient.on('error', (error) => {
          clearTimeout(timeout)
          logger.error('mattiWsClient connection error:', error)
          reject(error)
        })

        // Listen for notifications
        jaceWsClient.on('message', (data) => {
          logger.info('Jace Received notification:', data.toString())
          jaceNotificationPayload  = JSON.parse(data)
        })

        mattiWsClient.on('message', (data) => {
          logger.info('Matti Received notification:', data.toString())
          mattiNotificationPayload  = JSON.parse(data)
        })
      })

    })

    after(async () => {
      // Clean up WebSocket connection
      if (jaceWsClient?.readyState === WebSocket.OPEN && mattiWsClient?.readyState === WebSocket.OPEN) {
        await new Promise(resolve => {
          jaceWsClient.on('close', resolve)
          jaceWsClient.close()
          mattiWsClient.on('close', resolve)
          mattiWsClient.close()
        })
      }
      logger.info('PAYLOAD BEFORE CLEANUP', jaceNotificationPayload)
      // Reset notification
      jaceNotificationPayload  = null
      logger.info('PAYLOAD AFTER CLEANUP', jaceNotificationPayload)

    })

    /*  FOLLOW & UNFOLLOW TEST */

    describe('Follow User Test - WebSocket Notification Integration Test', () => {

      test('should successfully follow a user when not already following -  receive follow notification through WebSocket', async () => {

        // Matti follows Jace, jace recieves follow notification
        const response = await followUser(JACE.id) // targetUserId to follow
          .set('Authorization', `Bearer ${MATTI_TOKENS.accessToken}`)
          .expect(200)

        assert.strictEqual(response.body.message, 'Successfully followed')


        // verify (Jace) recieves Follow notification in real-time

        // Wait for notification with timeout
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('No notification received after 5s'))
          }, 5000)

          const checkInterval = setInterval(() => {
            if (jaceNotificationPayload ) {
              clearInterval(checkInterval)
              clearTimeout(timeout)
              resolve()
            }
          }, 100)
        })

        // Verify notification payload
        assert.ok(jaceNotificationPayload , 'Should receive notification')
        assert.strictEqual(jaceNotificationPayload.type, 'notification')
        assert.strictEqual(jaceNotificationPayload.data.data.type, 'Follow') // Follow action
        assert.strictEqual(jaceNotificationPayload.data.data.content.username, MATTI.username, ' User name that performed action' )

        // Verify follower relationship status between users
        const isFollowed = await checkFollowStatus(JACE.id)
          .set('Authorization', `Bearer ${MATTI_TOKENS.accessToken}`) // second user access token
          .expect(200)

        assert.strictEqual(isFollowed.body.isFollowing, true)

      })

      test('should successfully unfollow when already following user - no Notification', async () => {

        // Verify follower relationship status between users
        const isFollowed = await checkFollowStatus(JACE.id)
          .set('Authorization', `Bearer ${MATTI_TOKENS.accessToken}`) // second user access token
          .expect(200)

        assert.strictEqual(isFollowed.body.isFollowing, true)

        // CLICK THE FOLLOWING BUTTON ON UI, AUTOMATICALLY UNFOLLOW THE TARGET USER

        const unfollowResponse = await followUser(JACE.id) // targetUserId to unfollow
          .set('Authorization', `Bearer ${MATTI_TOKENS.accessToken}`)
          .expect(200)

        assert.strictEqual(unfollowResponse.body.message, 'Successfully unfollowed')


        // VERIFY UNFOLLOW STATUS
        const notFollowing = await checkFollowStatus(JACE.id)
          .set('Authorization', `Bearer ${MATTI_TOKENS.accessToken}`) // second user access token
          .expect(200)

        assert.strictEqual(notFollowing.body.isFollowing, false)

      })
    })

    // CHAT INTEGRATION TEST
    describe('Chat WebSocket Integration Tests', () => {

      // let mattiMessagePayload = mattiNotificationPayload
      test('should handle real-time message exchange between users', async () => {

        // Initialize chat session between users
        const newChat = await createChat()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .send({ otherUserId : MATTI.id }) // Id of Recipient
          .expect(201)

        // Verify chat creation
        assert.ok(newChat.body.id, 'Chat session should have a valid identifier')
        assert.strictEqual(
          newChat.body.user1_id,
          JACE.id,
          'Chat initiator should be recorded as user1'
        )
        assert.strictEqual(
          newChat.body.user2_id,
          MATTI.id,
          'Chat recipient should be recorded as user2'
        )
        assert.strictEqual(
          newChat.body.last_message_at,
          null,
          'New chat should have no message history'
        )

        // Send test message
        // JACE sends message to MATTI
        const newMessage = await sendMessage()
          .set('Authorization', `Bearer ${JACE_TOKENS.accessToken}`)
          .send({
            chat_id: newChat.body.id,
            content: 'mat i tried reaching you earlier.'
          })
          .expect(201)

        // Verify message sending
        assert.ok(newMessage.body.success, 'Message should be sent successfully')
        assert.strictEqual(
          newMessage.body.message,
          'Message sent successfully',
          'Server should confirm message delivery'
        )

        // Allow WebSocket connection to process message
        await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('No notification received after 5s'))
          }, 5000)

          const checkInterval = setInterval(() => {
            if (mattiNotificationPayload ) {
              clearInterval(checkInterval)
              clearTimeout(timeout)
              resolve()
            }
          }, 100)
        })

        // Verify message reception
        assert.ok(
          mattiNotificationPayload,
          'Recipient (matti) should receive real-time WebSocket message'
        )
        assert.deepStrictEqual(
          mattiNotificationPayload,
          {
            type: 'message_sent',
            data: {
              id: newMessage.body.data.id,
              chat_id: newMessage.body.data.chat_id,
              content: newMessage.body.data.content,
              sender_id: JACE.id,
              status: newMessage.body.data.status,
              created_at: newMessage.body.data.created_at,
              updated_at: newMessage.body.data.updated_at
            }
          },
          'WebSocket payload should match the sent message data'
        )
      })
    })

    test('Websocket should handle disconnection gracefully', async () => {
      // Wait for connection to stabilize
      await new Promise(resolve => setTimeout(resolve, 100))

      // Get WebSocket server instance
      const wsServer = app.ws

      // Store initial client count
      const beforeCount = wsServer.clients.size // 2
      logger.info('Before count', beforeCount)

      // Find Jace's client
      let foundClient = null
      wsServer.clients.forEach((client) => {
        if (client.userId === JACE.id) {
          foundClient = client
        }
      })

      // Verify we found the client
      assert.ok(foundClient, 'Client should be found before disconnection')
      assert.strictEqual(foundClient.userId, JACE.id, 'Client should have correct user ID')

      // Verify initial connection states
      assert.strictEqual(jaceWsClient.readyState, WebSocket.OPEN, 'jace wsClient.readyState should be OPEN (1)')
      assert.strictEqual(mattiWsClient.readyState, WebSocket.OPEN, 'matti wsClient.readyState should be OPEN (1)')

      // Close Jace's client connection
      jaceWsClient.close()

      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 100))

      // Close Matti's client connection
      mattiWsClient.close()

      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 100))

      // Verify connections are closed
      assert.notStrictEqual(jaceWsClient.readyState, WebSocket.OPEN, 'Jace WebSocket should be closed [wsClient.readyState should be 3, WebSocket.OPEN is 1]')
      assert.notStrictEqual(mattiWsClient.readyState, WebSocket.OPEN, 'Matti WebSocket should be closed [wsClient.readyState should be 3, WebSocket.OPEN is 1]')

      // Check if Jace's client was removed from server
      let clientFound = false
      wsServer.clients.forEach((client) => {
        if (client.userId === JACE.id) {
          clientFound = true
        }
      })

      assert.strictEqual(clientFound, false, 'Client should be removed from server')
      assert.strictEqual(
        wsServer.clients.size,
        beforeCount - 2,  // Both clients were closed
        'Client count should decrease by 2'
      )
    })
  })
})

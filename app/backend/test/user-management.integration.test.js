/* Integration Tests: User Management & Social Features
 * - Authentication
 * - Profile Operations
 * - Follow Relationships and Notifications
 * - WebSocket Communications
 */

const logger = require('../util/logger')
const { test, before, after, beforeEach, afterEach, describe } = require('node:test')
const assert = require('node:assert')
const path = require('path')
const { sequelize } = require('../util/db')
const { User, Follower, Chat, Message } = require('../models/index')
const jwt = require('jsonwebtoken')
const redisClient = require('../util/redis')
const WebSocket = require('ws')

const {
  app,
  server,
  createUser,
  loginUser,
  refreshToken,
  logout,
  updateUserProfileData,
  updateUserProfileAvatar,
  followUser,
  checkFollowStatus,
  createChat,
  sendMessage
} = require('./test_helper')

const mockUsers = {
  valid: {
    email: 'jace@test.com',
    password: 'Test123!@#',
    dob: '2001-01-01'
  },
  invalid: {
    email: 'invalid@example.com',
    password: '123',
    dob: 'invalid-date'
  },
  valid2 : {
    email: 'matti@test.com',
    password: 'salenen',
    dob: '2001-01-02'
  }
}

let port

before(async () => {
  try {
    await sequelize.authenticate()
    logger.info('Test database connected')
    port = server.listen().address().port

  } catch (error) {
    logger.error('Database connection failed:', error)
    throw error
  }
})

after(async () => {
  try {
    await sequelize.close()
    logger.info('Test database connection closed')
  } catch (error) {
    logger.error('Error closing database:', error)
    throw error
  }
})



/* AUTHENTICATION INTEGRATION TEST */

describe('Authentication Tests', async () => {
  beforeEach(async () => {
    try {
      // PostgreSQL-specific: Disable triggers temporarily
      await sequelize.query('SET session_replication_role = replica')

      // Clean all tables that might have references
      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
      ])

      // Re-enable triggers
      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }
  })

  describe('User Registration', () => {
    test('Successfully creates new user with valid data', async () => {
      const response = await createUser(mockUsers.valid)
        .expect(201)
        .expect('Content-Type', /application\/json/)

      // Verify response structure
      assert.ok(response.body.user, 'Response should contain user object')
      assert.ok(response.body.accessToken, 'Response should contain access token')
      assert.ok(response.body.refreshToken, 'Response should contain refresh token')

      // Verify user data
      const { user } = response.body
      assert.equal(user.email, mockUsers.valid.email, 'Email should match')
      assert.ok(user.id, 'User should have an ID')
      assert.ok(user.username, 'User should have a username generated by the system from email')
      assert.ok(!user.password, 'Password should not be returned')
    })


    test('Prevents duplicate user registration', async () => {
    // First registration
      await createUser(mockUsers.valid).expect(201)

      // Attempt duplicate registration
      const response = await createUser(mockUsers.valid)
        .expect(409)
        .expect('Content-Type', /application\/json/)

      assert.equal(response.body.error, 'Email already exists')
    })

    test('Validates required fields', async () => {
      const invalidUsers = [
        { password: 'test123', dob: '2001/1/1' }, // Missing email
        { email: 'test@example.com', dob: '2001/1/1' }, // Missing password
        { email: 'test@example.com', password: 'test123' } // Missing dob
      ]

      for (const invalidUser of invalidUsers) {
        const response = await createUser(invalidUser)
          .expect(400)
          .expect('Content-Type', /application\/json/)

        assert.ok(response.body.error, 'Should return error message')
        assert.equal(response.body.error, 'Email, password and date of birth are required')
      }
    })
  })

  describe('User Login', () => {
    beforeEach(async () => {
      await createUser(mockUsers.valid)
    })

    test('Successfully logs in with valid credentials', async () => {
      const credentials = {
        email: mockUsers.valid.email,
        password: mockUsers.valid.password
      }

      const response = await loginUser(credentials)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      // Verify response structure
      assert.ok(response.body.user, 'Response should contain user object')
      assert.ok(response.body.accessToken, 'Response should contain access token')
      assert.ok(response.body.refreshToken, 'Response should contain refresh token')

      // Verify user data
      const { user } = response.body
      assert.equal(user.email, credentials.email, 'Email should match')
      assert.ok(!user.password, 'Password should not be returned')
    })

    test('Rejects invalid credentials', async () => {
      const invalidCredentials = [
        { email: mockUsers.valid.email, password: mockUsers.invalid.password },
        { email: mockUsers.invalid.email, password: mockUsers.valid.password }
      ]

      for (const credentials of invalidCredentials) {
        const response = await loginUser(credentials)
          .expect(401)
          .expect('Content-Type', /application\/json/)

        assert.equal(response.body.error, 'Invalid credentials')
      }
    })
  })
  describe('Token Refresh Tests', () => {
    let validUser, validUserTokens

    beforeEach(async () => {
      const response = await createUser(mockUsers.valid)
        .expect(201)
        .expect('Content-Type', /application\/json/)
      validUser = response.body.user
      validUserTokens = {
        accessToken: response.body.accessToken,
        refreshToken: response.body.refreshToken
      }
    })

    test('Successfully refreshes access token', async () => {
      const response = await refreshToken()
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send({ refreshToken: validUserTokens.refreshToken })
        .expect(200)
        .expect('Content-Type', /application\/json/)

      // Verify response
      assert.ok(response.body.accessToken, 'Should return new access token')
      assert.ok(response.body.refreshToken, 'Should return new refresh token')
      assert.notEqual(
        response.body.accessToken,
        validUserTokens.accessToken,
        'New access token should be different'
      )
      assert.notEqual(
        response.body.refreshToken,
        validUserTokens.refreshToken,
        'New refresh token should be different'
      )


      // Check if new token is not blacklisted
      const isNotBlacklisted = await redisClient.get(`bl_${response.body.refreshToken}`)
      assert.equal(isNotBlacklisted, null, 'New token should not be blacklisted')

    })

    test('Rejects invalid token formats', async () => {
      // JWT will return 401 for these cases
      const invalidUserTokens = [
        'not-a-token',
        'invalid.jwt.format',
        `${validUserTokens.refreshToken}corrupted`
      ]

      for (const invalidToken of invalidUserTokens) {
        await refreshToken()
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .send({ refreshToken: invalidToken })
          .expect(401)  // JWT verification fails with 401
          .expect('Content-Type', /application\/json/)
      }
    })

    test('Rejects blacklisted but valid format tokens', async () => {
      // First use valid tokens
      await refreshToken()
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send({ refreshToken: validUserTokens.refreshToken })
        .expect(200)

      // Try to reuse the now-blacklisted token
      const blacklistedResponse = await refreshToken()
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send({ refreshToken: validUserTokens.refreshToken })
        .expect(400)  // Blacklisted token returns 400
        .expect('Content-Type', /application\/json/)

      assert.equal(
        blacklistedResponse.body.error,
        'Token has been revoked',
        'Should reject blacklisted token'
      )

      // Verify Token is Blacklisted on redis
      const isBlacklisted = await redisClient.get(`bl_${validUserTokens.refreshToken}`)
      assert.equal(isBlacklisted, 'true', 'Old token should be blacklisted')
    })

    test('Reject request with NO Authorization header or MalFormated token', async () => {

      // Try with NO Authorization Header
      const invalidResponse = await refreshToken()
        .set('Authorization', 'Bearer invalid-accessToken')
        .send({ refreshToken: validUserTokens.refreshToken })
        .expect(401)  // Unauthorized - invalid access token


      assert.equal(
        invalidResponse.body.error,
        'Please authenticate',
        'Should reject invalid access token'
      )

      // Try with NO refresh Token
      const noTokenResponse = await refreshToken()
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .expect(400)

      assert.ok(noTokenResponse.body.error)
      assert.equal(noTokenResponse.body.error, 'No token', 'Should respond with No Token' )
    })

    test('Rejects expired tokens', async () => {
      // Create an expired token
      const expiredToken = jwt.sign(
        { id: validUser.id },
        process.env.REFRESH_SECRET,
        { expiresIn: '0s' }
      )

      await refreshToken()
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send({ refreshToken: expiredToken })
        .expect(401)  // Expired tokens return 401
        .expect('Content-Type', /application\/json/)
    })
  })

  describe('User Log out',() => {
    test('Successfully Log out', async () => {
      // Register testUser
      const registerResponse  = await createUser(mockUsers.valid)
        .expect(201)
        .expect('Content-Type', /application\/json/)


      const { accessToken } = registerResponse.body

      const response = await logout()
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      assert.equal(response.body.message, 'Logged out successfully' )

      //  check if token is blacklisted
      const isBlacklisted = await redisClient.get(`bl_${accessToken}`)
      assert.equal(isBlacklisted, 'true', 'Token should be blacklisted')

    })
  })

})


describe('User API Tests', async () => {
  beforeEach(async () => {
    try {
      await sequelize.query('SET session_replication_role = replica')
      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
      ])
      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }
  })

  describe('User Profile Update test', () => {
    let validUser, validUserTokens

    beforeEach(async () => {
      const response = await createUser(mockUsers.valid)
        .expect(201)
        .expect('Content-Type', /application\/json/)
      validUser = response.body.user
      validUserTokens = {
        accessToken: response.body.accessToken,
        refreshToken: response.body.refreshToken
      }
    })

    test('should update user and return 200 status with updated data when valid updates provided', async () => {
      const updates = {
        first_name: 'Jace',
        last_name: 'Sam',
        bio: 'Software Developer',
        website_url: 'https://example.com',
        gender: 'male',
        country: 'CH',
        language: 'de'
      }

      const response = await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(200)
        .expect('Content-Type', /application\/json/)

      const { success, data } = response.body

      delete data.created_at
      delete data.updated_at

      assert.ok(success)
      assert.deepStrictEqual(data, {
        ...updates,
        id: validUser.id,
        email: validUser.email,
        username: validUser.username,
        dob: '2001-01-01', // Match the exact format returned by the database,
        avatar_url: validUser.avatar_url
      })
    })


    test('should remove sensitive fields from update object before processing', async () => {
      const updates = {
        first_name: 'Jace',
        password: 'NewSecret123!', // password is removed
        email: 'new@example.com', // email is removed,
      }

      const response = await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(200)

      assert.ok(response.body.success)
      assert.ok(!response.body.data.password)
      assert.strictEqual(response.body.data.email, validUser.email)
    })


    test('should invalidate redis cache after successful update', async () => {
      const updates = { first_name: 'Jace' }

      // Update user
      await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(200)

      // Verify cache is invalidated
      const cachedData = await redisClient.get(`user${validUser.id}`)
      assert.equal(cachedData, null)
    })


    test('should return 404 when user does not exist, 400 when id is not a valid UUID v4 format', async () => {
      const ids = { nonexistentId: '807deeb6-e1c7-4f01-b9cd-1c909f1eccb4', nonValidUUID_v4 : '999999' }
      const updates = { first_name: 'John' }

      const nonExistentResponse = await updateUserProfileData(ids.nonexistentId)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(404)

      assert.strictEqual(nonExistentResponse.body.success, false)
      assert.strictEqual(nonExistentResponse.body.message, 'User not found')


      const nonValidResponse = await updateUserProfileData(ids.nonValidUUID_v4)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(400)

      assert.strictEqual(nonValidResponse.body.error, 'Invalid ID format')
      assert.strictEqual(nonValidResponse.body.details, 'ID must be a valid UUID v4')
    })



    test('should handle empty update object gracefully', async () => {
      const response = await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send({})
        .expect(400)

      assert.equal(response.body.error, 'No update data provided')
    })


    test('should ignore invalid field names in update object', async () => {
      const updates = {
        first_name: 'Jace',
        invalidField: 'Invalid Value'
      }

      const response = await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(200)

      assert.ok(response.body.success)
      assert.equal(response.body.data.first_name, 'Jace')
      assert.ok(!response.body.data.invalidField)
    })


    test('should handle database errors gracefully', async () => {
      // Force a database error by passing invalid data type
      const updates = {
        username: null //  username doesn't accept null
      }

      const response = await updateUserProfileData(validUser.id)
        .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
        .send(updates)
        .expect(400)

      assert.strictEqual(response.body.error, 'Validation error')
      assert.strictEqual(response.body.details[0].field, 'username')
      assert.strictEqual(response.body.details[0].message, 'User.username cannot be null')
      assert.strictEqual(response.body.details[0].type, 'notNull Violation')

    })



    // Avatar update Test
    describe('User Avatar Update Tests', async () => {
      // profile Image path
      const testImagePath = path.join(__dirname, 'test-files/profile.jpeg')

      test('should update user avatar and return 200 when valid file and ID provided', async () => {

        const response = await updateUserProfileAvatar(validUser.id)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .attach('avatar', testImagePath) // .attach() handles the FormData creation internally
          .expect(200)
          .expect('Content-Type', /application\/json/)

        assert.ok(response.body.success)
        assert.notStrictEqual(response.body.data.avatar_url, validUser.avatar_url)
      })



      test('should return user data without password_hash when update successful', async () => {

        const response = await updateUserProfileAvatar(validUser.id)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .attach('avatar', testImagePath)
          .expect(200)

        assert.strictEqual(response.body.success, true)
        assert.ok(!response.body.data.password_hash)
        assert.ok(response.body.data.id)
        assert.ok(response.body.data.username)
      })

      test('should invalidate Redis cache when avatar update successful', async () => {

        await updateUserProfileAvatar(validUser.id)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .attach('avatar', testImagePath)
          .expect(200)

        const isInvlidated = await redisClient.get(`user:${validUser.id}`)

        assert.equal(isInvlidated, null, 'User should Invalidated')
      })

      test('should return 400 when no image file provided', async () => {
        const response = await updateUserProfileAvatar(validUser.id)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .expect(400)

        assert.strictEqual(response.body.success, false)
        assert.strictEqual(response.body.message, 'No image file provided')
      })

      test('should return 404 when user ID does not exist', async () => {
        const nonExistentId = '99999999-9999-9999-9999-999999999999'

        const response = await updateUserProfileAvatar(nonExistentId)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .attach('avatar', testImagePath)
          .expect(400)

        assert.strictEqual(response.body.error, 'Invalid ID format')
        assert.strictEqual(response.body.details, 'ID must be a valid UUID v4')
      })


      test('should handle missing file', async () => {
        const response = await updateUserProfileAvatar(validUser.id)
          .set('Authorization', `Bearer ${validUserTokens.accessToken}`)
          .expect(400)

        assert.strictEqual(response.body.success, false)
        assert.strictEqual(response.body.message, 'No image file provided')
      })

    })

  })
})




/*  FOLLOW & UNFOLLOW TEST */

describe('Follow User Test', () => {
  let validUser, validUserTokens

  beforeEach(async () => {
    try {
      await sequelize.query('SET session_replication_role = replica')

      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
        Follower.destroy({ truncate: true, cascade: true }),
      ])

      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }
  })

  beforeEach(async () => {
    // target user (who will receive notification)
    const targetResponse  = await createUser(mockUsers.valid)
      .expect(201)
      .expect('Content-Type', /application\/json/)
    validUser = targetResponse.body.user
    validUserTokens = {
      accessToken: targetResponse.body.accessToken,
      refreshToken: targetResponse.body.refreshToken
    }
  })


  test('should successfully follow a user when not already following', async () => {
    // Create a follower account for testing follow functionality
    const secondUser = await createUser(mockUsers.valid2)
      .expect(201)
      .expect('Content-Type', /application\/json/)

    const { accessToken } = secondUser.body

    // Initiate follow relationship: follower -> target user
    const response = await followUser(validUser.id) // targetUserId to follow
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200)

    assert.strictEqual(response.body.message, 'Successfully followed')

    // Verify follower relationship status between users
    const isFollowed = await checkFollowStatus(validUser.id)
      .set('Authorization', `Bearer ${accessToken}`) // second user access token
      .expect(200)

    assert.strictEqual(isFollowed.body.isFollowing, true)

  })



  test('should successfully unfollow when already following user', async () => {
    const secondUser = await createUser(mockUsers.valid2)
      .expect(201)
      .expect('Content-Type', /application\/json/)

    const { accessToken } = secondUser.body

    const response = await followUser(validUser.id) // targetUserId to follow
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200)

    assert.strictEqual(response.body.message, 'Successfully followed')

    // Verify follower relationship status between users
    const isFollowed = await checkFollowStatus(validUser.id)
      .set('Authorization', `Bearer ${accessToken}`) // second user access token
      .expect(200)

    assert.strictEqual(isFollowed.body.isFollowing, true)

    // CLICK THE FOLLOWING BUTTON ON UI, AUTOMATICALLY UNFOLLOW THE TARGET USER

    const unfollowResponse = await followUser(validUser.id) // targetUserId to unfollow
      .set('Authorization', `Bearer ${accessToken}`)
      .expect(200)

    assert.strictEqual(unfollowResponse.body.message, 'Successfully unfollowed')


    // VERIFY UNFOLLOW STATUS
    const notFollowing = await checkFollowStatus(validUser.id)
      .set('Authorization', `Bearer ${accessToken}`) // second user access token
      .expect(200)

    assert.strictEqual(notFollowing.body.isFollowing, false)

  })



  // WEBSOCKET TEST

  describe('WebSocket Notification Integration', async () => {
    let wsClient
    let notificationPayload  = null

    beforeEach(async () => {


      // Use the same server instance that has WebSocket attached
      // const port = server.listen().address().port

      // Connect WebSocket client for target user
      wsClient = new WebSocket(
        `ws://localhost:${port}?token=${validUserTokens.accessToken}`
      )

      // Wait for WebSocket connection with proper error handling
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('WebSocket connection timeout'))
        }, 5000)

        wsClient.on('open', () => {
          clearTimeout(timeout)
          logger.info('WebSocket connected successfully')
          resolve()
        })

        wsClient.on('error', (error) => {
          clearTimeout(timeout)
          logger.error('WebSocket connection error:', error)
          reject(error)
        })

        // Listen for notifications
        wsClient.on('message', (data) => {
          logger.info('Received notification:', data.toString())
          notificationPayload  = JSON.parse(data)
        })
      })
    })

    afterEach(async () => {
      // Clean up WebSocket connection
      if (wsClient?.readyState === WebSocket.OPEN) {
        await new Promise(resolve => {
          wsClient.on('close', resolve)
          wsClient.close()
        })
      }

      // Reset notification
      notificationPayload  = null
    })


    test('should receive follow notification through WebSocket', async () => {
      let followerTokens, followerUser

      // Create follower user who will trigger notifications
      const followerResponse = await createUser(mockUsers.valid2)
        .expect(201)
      followerUser = followerResponse.body.user
      followerTokens = {
        accessToken: followerResponse.body.accessToken,
        refreshToken: followerResponse.body.refreshToken
      }

      // Perform follow action
      await followUser(validUser.id)
        .set('Authorization', `Bearer ${followerTokens.accessToken}`)
        .expect(200)

      // Wait for notification with timeout
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('No notification received after 5s'))
        }, 5000)

        const checkInterval = setInterval(() => {
          if (notificationPayload ) {
            clearInterval(checkInterval)
            clearTimeout(timeout)
            resolve()
          }
        }, 100)
      })

      // Log the full notification structure
      // logger.info('Received notification structure:', JSON.stringify(notificationPayload , null, 2))

      // Verify notification content
      assert.ok(notificationPayload , 'Should receive notification')
      assert.strictEqual(notificationPayload .type, 'notification')
      assert.strictEqual(notificationPayload .data.data.type, 'Follow')
      assert.strictEqual(notificationPayload .data.data.content.username, followerUser.username, ' Username that performed the action' )

    })


    test('should handle disconnection gracefully', async () => {
      // Wait for connection to stabilize
      await new Promise(resolve => setTimeout(resolve, 100))

      // Get WebSocket server instance
      const wsServer = app.ws

      // Store initial client count
      const beforeCount = wsServer.clients.size // 1

      // Get client info
      let foundClient = null
      wsServer.clients.forEach((client) => {
      // The client object itself contains the data
        if (client.userId === validUser.id) {
          foundClient = client
        }
      })

      // Verify we found the client
      assert.ok(foundClient, 'Client should be found before disconnection')
      assert.strictEqual(foundClient.userId, validUser.id, 'Client should have correct user ID')

      // Verify initial connection
      assert.strictEqual(wsClient.readyState, WebSocket.OPEN, 'wsClient.readyState should be (1)')

      // Close client connection
      wsClient.close()

      // Wait for cleanup
      await new Promise(resolve => setTimeout(resolve, 100))

      // verify close connection
      assert.notStrictEqual(wsClient.readyState, WebSocket.OPEN, 'WebSocket should be connected [wsClient.readyState should be 3, WebSocket.OPEN is 1 ]')

      // Check if client was removed
      let clientFound = false
      wsServer.clients.forEach((client) => {
        const clientData = wsServer.clients.get(client)
        if (clientData && clientData.userId === validUser.id) {
          clientFound = true
        }
      })

      assert.strictEqual(clientFound, false, 'Client should be removed')
      assert.strictEqual(
        wsServer.clients.size,
        beforeCount - 1,
        'Client count should decrease by 1'
      )
    })

  })
})


// CHAT INTEGRATION TEST
describe('Chat WebSocket Integration Tests', () => {
  let messageRecipient
  let recipientTokens
  let wsClient
  let receivedMessage = null

  // Database cleanup before each test
  beforeEach(async () => {
    try {
      await sequelize.query('SET session_replication_role = replica')

      await Promise.all([
        User.destroy({ truncate: true, cascade: true }),
        Follower.destroy({ truncate: true, cascade: true }),
        Chat.destroy({  truncate: true, cascade: true }),
        Message.destroy({  truncate: true, cascade: true }),
      ])

      await sequelize.query('SET session_replication_role = default')
    } catch (error) {
      logger.error('Database cleanup error', error)
      throw error
    }

    const recipientResponse = await createUser(mockUsers.valid)
      .expect(201)

    messageRecipient = recipientResponse.body.user
    recipientTokens = {
      accessToken: recipientResponse.body.accessToken,
      refreshToken: recipientResponse.body.refreshToken
    }

  })

  beforeEach(async () => {

    // const port = server.listen().address().port

    wsClient = new WebSocket(
      `ws://localhost:${port}?token=${recipientTokens.accessToken}`
    )

    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('WebSocket connection timeout'))
      }, 5000)

      wsClient.on('open', () => {
        clearTimeout(timeout)
        logger.info('WebSocket connected successfully')
        resolve()
      })

      wsClient.on('error', (error) => {
        clearTimeout(timeout)
        logger.error('WebSocket connection error:', error)
        reject(error)
      })

      // Listen for message
      wsClient.on('message', (data) => {
        logger.info('Received message:', data.toString())
        receivedMessage = JSON.parse(data)
      })
    })

  })

  afterEach(async () => {
    // Clean up WebSocket connection
    if (wsClient?.readyState === WebSocket.OPEN) {
      await new Promise(resolve => {
        wsClient.on('close', resolve)
        wsClient.close()
      })
    }

    // Reset message
    receivedMessage = null
  })


  test('should handle real-time message exchange between users', async () => {
    let messageSender
    let senderTokens

    // Create message sender user
    const senderResponse = await createUser(mockUsers.valid2)
      .expect(201)

    messageSender = senderResponse.body.user
    senderTokens = {
      accessToken: senderResponse.body.accessToken,
      refreshToken: senderResponse.body.refreshToken
    }

    // Initialize chat session between users
    const newChat = await createChat()
      .set('Authorization', `Bearer ${senderTokens.accessToken}`) // Sender created chat session in this case
      .send({ otherUserId : messageRecipient.id }) // Id of messageRecipient
      .expect(201)

    // Verify chat creation
    assert.ok(newChat.body.id, 'Chat session should have a valid identifier')
    assert.strictEqual(
      newChat.body.user1_id,
      messageSender.id,
      'Chat initiator should be recorded as user1'
    )
    assert.strictEqual(
      newChat.body.user2_id,
      messageRecipient.id,
      'Chat recipient should be recorded as user2'
    )
    assert.strictEqual(
      newChat.body.last_message_at,
      null,
      'New chat should have no message history'
    )

    // Send test message
    const newMessage = await sendMessage()
      .set('Authorization', `Bearer ${senderTokens.accessToken}`)
      .send({
        chat_id: newChat.body.id,
        content: 'Jace i tried reaching you earlier. Sending you a message instead.'
      })
      .expect(201)

    // Verify message sending
    assert.ok(newMessage.body.success, 'Message should be sent successfully')
    assert.strictEqual(
      newMessage.body.message,
      'Message sent successfully',
      'Server should confirm message delivery'
    )

    // Allow WebSocket connection to process message
    await new Promise(resolve => setTimeout(resolve, 100))

    // Verify message reception
    assert.ok(
      receivedMessage,
      'Recipient should receive real-time WebSocket notification'
    )
    assert.deepStrictEqual(
      receivedMessage,
      {
        type: 'message_sent',
        data: {
          id: newMessage.body.data.id,
          chat_id: newMessage.body.data.chat_id,
          content: newMessage.body.data.content,
          sender_id: newMessage.body.data.sender_id,
          status: newMessage.body.data.status,
          created_at: newMessage.body.data.created_at,
          updated_at: newMessage.body.data.updated_at
        }
      },
      'WebSocket payload should match the sent message data'
    )
  })
})